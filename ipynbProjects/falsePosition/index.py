# -*- coding: utf-8 -*-
"""CNfalsePositionMethod.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x8Gn2zyi4EbgyTCCcSHISnEDX4iHp7hG
"""

# método da falsa posição

# Commented out IPython magic to ensure Python compatibility.
# importação das bibliotecas
# %matplotlib inline
import matplotlib.pyplot as plt
import numpy as np
from math import log

def f(x):
  return (x**3 - 9*x + 3)

def xn(a, b):
  return ((a*(f(b)) - (b * (f(a))))/((f(b)) - (f(a))))

def isThereARoot(a, b):
  if (a * b < 0):
    return 1
  else:
    return 0

a = float(input('Entre com o primeiro valor: '))
b = float(input('Entre com o segundo valor: '))
tol = float(input('Entre com o valor da tolerância: '))

iteration = 0
a_zero = a
b_zero =  b
xf = np.linspace(a-1, b+1, 100)

if( isThereARoot(f(a), f(b)) ):
  
  x = xn(a, b)

  while( abs(f(x)) < tol ):

    print(f'ITERAÇÃO {iteration} - Intervalo: [{a}, {b}]')
    x = xn(a, b)
    print(f'ITERAÇÃO {iteration} - O valor x{iteration} foi definido como {x}.')

    if(isThereARoot(a, x)):
      print(f'ITERAÇÃO {iteration} - O valor b foi definido como {x}, pois f({b}) = {f(b)} ; f({x}) = {f(x)}.')
      b = x
    else:
      print(f'ITERAÇÃO {iteration} - O valor a foi definido como {x}, pois f({a}) = {f(a)} ; f({x}) = {f(x)}.')
      a = x
    
    iteration+=1
    
    print(f'Novo intervalo: [{a}, {b}]')

else:
  print('Não há raízes reais neste intervalo [{a}, {b}]')

print(f'Intervalo após {iteration+1} iterações: [{a}, {b}], raiz aproximada: {x}')

plt.grid()
plt.scatter(a_zero, f(a_zero), c='red')
plt.scatter(b_zero, f(b_zero), c='red')
plt.scatter(a, f(a), c='blue')
plt.scatter(b, f(b), c='blue')

plt.scatter(x, f(x), c='yellow')
plt.plot(xf, f(xf), c='purple')